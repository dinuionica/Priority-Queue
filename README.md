# PRIORITY Queue


ARCHIVE CONTENT:

AVL.cpp Avl.h -> Implementing the AVL data structure

MaxHeap.cpp MaxHeap.h -> Implementing the Max Heap

test_avl_algo.cpp -> The file required by the checker to verify
tests specific to the AVL algorithm

test_avl_algo.cpp -> The file required by the checker to verify
tests specific to the Heap algorithm

checker_avl_algo.cpp checker_heap_algo.cpp -> two checkers made for
to test the correctness of the tests, their output and to determine
duration of execution of a test

Makefile -> The makefile that contains the build and run rules

Readme -> The file that contains details about the archive and implementations

checker.py -> the checker that verifies the correctness of the tests

generator.py -> python script to generate tests

IN -> folder contains input tests (input tests)

OUT folder -> contain out tests (output tests)

the TEST_OUT -> folder contains the tests generated by checker_avl and checker_heap

-------------------------------------------------- ----------------------------

IMPLEMENTATION:

The implementation of the two algorithms was done using the C ++ language,
and for a good modularization of the code I chose to use header files.

AVL:

Functions:

- add -> add a new node in Avl
- remove_max -> the maximum item is obtained, and then it is deleted
- max_element -> returns the element with the maximum value
- preorder -> function that displays avl elements in preorder (debug)
- height -> within this function the height of a node is calculated
- preorder_util -> auxiliary function that displays the value of the current item
and then scroll left and right under the tree
- create_node -> function creates a new node with a desired value
- rotate_right -> in this function a right rotation is performed
of a node and the height is updated
- rotate_left -> similar to the rotate_right function except that a rotation is applied
to the left of the node
- get_balance -> within this function the equilibrium factor is calculated
of a node by the difference in heights between the left and right subtree
- fix_avl -> within this function the equilibrium factor is calculated and
then balance the shaft using right and left rotations
- min_node -> determines the node with the minimum value in avl
- max_node -> determines the node with the maximum value in avl
- add_util -> add node as inserted in a binary search tree,
and then the height is updated and the avl is balanced
- remove_util -> in this function we look for the node with the value that
we want to delete it, then delete the node. If the node does not have two successors, this one
it will be replaced by one of its non-zero successors. Otherwise the node will be replaced
with the smallest node in the right subtree.

HEAP:

I chose to implement the max heap using an STL vector, removing the information
related to pointers, print using a formula to calculate the parent and
copies of a node based on the index in the vector.

Functions:

- parent -> returns the parent of the node with the index i
- left_child_node -> returns the left child of the node with index i
- right_child_node -> returns the right child of node with index i
- size -> within this function we return the current size of the heap
- is_empty -> check if the heap contains items, or if it is empty
- heapify_down -> the recursive function that ensures the rearrangement of the elements
to maintain the max heap rule. Heapify down is used when
we remove the upper element from the heap.
- heapify_up -> the recursive function that ensures the rearrangement of the elements
to maintain the max heap rule. We use the function when inserting a new one
item in a heap. We add it to the bottom of the heap tree and pass
up in the tree as we compare with the current parent element and them
we exchange if necessary.
- add -> in this function we add a new element at the end of the vector
then we determine the last position and apply the heapify_up function to
rearrange the elements.
- max_element-> within this function we return the element from the first one
position in vector (highest value element)
- remove_max -> in this function we access the last element in the vector,
we add it to the first position, delete the last element and call the function
heapify_down on the first node to rearrange the items in the desired order

-------------------------------------------------- ----------------------------

TEST_AVL_ALGO.cpp TEST_HEAP_ALGO.cpp

These two files contain the code needed by the checker to test the algorithms.
In them I created the two files (the input and the output).
Then I read the data from the input file, I ran the algorithm based on it
inputs and I redirected the results to output files.

-------------------------------------------------------------------------------

CHECKER_AVL_ALGO.cpp CHECKER_HEAP_ALGO.cpp

Aceste doua fisiere contin codul sursa a doua checkere realizate folosind c++.
Am create aceste doua fisiere pentru a testa corectitudinea algoritmilor
implementati, pentru a determina timpul de executie al fiecarui test specific
unui algoritm, respectiv pentru debug.

In cadrul programelor, pentru un numar dat de teste, citesc datele de intrare 
din folderul in, rulez algoritmul si afiseaz rezultatele in folder 
TEST_OUT/algoritm. Apoi verific daca fisierele de output obtinute sunt identice
cu cele din folder-ul OUT. In caz afirmativ, am afisat un mesaj corespunzator 
"Test passed", iar in caz contrat afisez "Test failed". Pentru fiecare test am 
determinat timpul de exectutie din punctul in care algoritm-ul incepe sa ruleze
si pana la final. Am afisat ca output durata de executie in microsecunde.

-------------------------------------------------------------------------------

STRUCTURA FOLDERELOR IN / OUT / TEST_OUT

folder-ul in : 

-> contine 23 de teste de intrare care vor fi aplicate fiecarui algoritm 
-> fiecare test este numit "testX.in", unde X reprezintă numărul testului

STRUCTURA TEST
-> in cadrul fiecarui teste se afla o serie de comenzi
-> daca numele comenzii este PUSH se va citi si o valoare si se va realiza
adaugarea valorii respective in coada (operatia push)
-> daca numele comenzii este pop se va sterge elementul cu prioritatea 
maxima din coada (operatia pop)
-> daca numele comenzii este top se va returna elementul cu prioritatea 
maxima din coada (operatia top)


teste [1-8] -> verifica un numar redus de operatii
            -> testeaza corectitudinea generala a implementarii
            -> elementele au valori intre [0 - 1000]
            -> se introduc in coada intre [0 - 100] elemente

test [9]    -> contine 1000 de operatii de push
            -> elementele sunt adaugate in ordine crescatoare 
            -> elementele au valori intre [0 -1000]

test [10]   -> contine 1000 de operatii de push
            -> elementele sunt adaugate in ordine descrescatoare
            -> elementele au valori intre [0 - 10000]

teste [11-15] -> contin intre 0-10000 de operatii
              -> valorile elementelor sunt cuprine intre [0-10000]
            
             
teste [16-18] -> contin intre [10000-99999] de operatii
              -> valorile elementelor sunt cuprinse intre [0-90000]
            

teste [19-20] -> contin peste 100000 de operatii
              -> valorile elementelor sunt cuprinse intre [0-100000]

teste[21-22] -> contin peste 1000000 de operatii
             -> valorile elementelor sunt cuprinse intre [0-1000000]
             -> testeaza intr-un mod complex algoritmii implementati

test [23]  -> contine peste 10000000 de operatii 
           -> valorile elementelor sunt cuprinse intre [0-1000000]

Pentru testele [11-23] mai intai se genereaza un numar random de operatii
de push iar apoi se genereaza un numar random de operatii diferite.
     

folder-ul out:
-> contine trei foldere: best, p1 si p2 deoarece in cadrul testelor exista
elemente cu aceeasi prioritate (duplicate), iar output generat este diferit
pentru cei doi algoritmi
-> fiecare subfolder contine 23 de teste de iesire care reprezinta testele 
corecte ce ar trebui obtinute
-> fiecare test este numit "testX.out", unde X reprezintă numărul testului

folder-ul test_out:
-> contine doua foldere: p1 si p2 
-> fiecare subfolder contine 23 de teste de iesire, generate in urma rularii
fisierelor checker_avl_algo.cpp si checker_heap_algo.cpp
-> fiecare test este numit "testX.out", unde X reprezintă numărul testului

-------------------------------------------------------------------------------

CHECKER.py

Checker-ul realizat pentru a testa corectitudinea algoritmilor.

-------------------------------------------------------------------------------

GENERATOR.py

Acest fisier contine codul sursa al unui script realizat in python pentru a 
genera o serie de teste random pe baza unor criterii folosind modulul random.
Pentru realizare unui test sunt introduse de la tastatura o serie de date:

- numarul testului pe care dorim sa il creem
- numarul de elemente al liste de numere
- range-ul maxim al elementelor
- yes / no daca dorim o lista de numere sortate
    - lista sortata - crescator
                    - descrescator
- upper limit pentru numarul de operatii de push
- upper limit pentru numarul de operatii random 

In cadrul generatorului, am creat o lista de cu cele trei comenzi. Apoi am 
creat pe baza datelor introduse de la tastatura o lista de numere, care poate
fi sortata sau nu. Am creat un fisier pentru testul dorit, si am generat random
un numar de operatii de push pe care le-am afisat in fisier. Apoi am generat
random un numar de operatii dintre cele trei posibile. Valorile care sunt 
adaugate in coada sunt generate random din lista de numere creata initial.

-------------------------------------------------------------------------------

MAKEFILE:

- build:
        compileaza toate executabilele

- run-best 
        testarea celui mai bun algoritm

- run-p1
        testarea algoritmului de heap

- run-p2
        testarea algoritmului avl

- Maxheap.o 
        compileaza executabilul pentru heap
        
- test_heap.o 
        compileaza executabilul pentru testarea algoritmului heap

- AVL.o 
        compileaza executabilul pentru avl

- test_avl.o 
        compileaza executabilul pentru testarea algoritmului avl

- checker-avl-cpp:
        compileaza si ruleaza checker-ul secundar pentru avl

- checker-heap-cpp:
        compileaza si ruleaza checker-ul secundar pentru heap

- clean

-------------------------------------------------------------------------------

COMENZI UTILE

Rulare generator:

python3 generator.py

Rulare checker Heap algoritm:

python3 checker.py --algo p1 --task 6 --unique-tests

Rulare checker AVL algoritm:

python3 checker.py --algo p2 --task 6 --unique-tests

Rulare checker best algoritm:

python3 checker.py --algo best --task 6 --unique-tests
-------------------------------------------------------------------------------

OBSERVATII / CONCLUZII 

Pe baza testelor generate, analizand in medie timpul de executie al fiecarui 
algoritm am observat ca algoritmul de heap este superior celui de avl. Testele 
ruleaza intr-un timp mai scurt. Si din punct de vedere al implementarii, heap-ul
a fost mai usor de realizat comparativ cu avl. Un nou avantaj al heap-ului este 
legat de complexitatea in care este returnat elementul maxim, aceasta fiind O(1)
in vreme ce in cadrul avl-ului aceeasi operatie vine cu o complexitate O(log n).

-------------------------------------------------------------------------------

REFERINTEE :

Inspiratie si Secvente de cod preluate de la : 

https://www.geeksforgeeks.org/avl-tree-set-1-insertion/

https://www.geeksforgeeks.org/avl-tree-set-2-deletion/

https://www.softwaretestinghelp.com/avl-trees-and-heap-data-structure-in-cpp/

https://ocw.cs.pub.ro/courses/sd-ca/laboratoare/lab-11

https://ocw.cs.pub.ro/courses/sd-ca/laboratoare/lab-09 -> Schelete de cod

-------------------------------------------------------------------------------
