# Priority Queue Implementation

-------------------------------------------------------------------------------
## Archive Content :

AVL.cpp Avl.h -> Implementing the AVL data structure

MaxHeap.cpp MaxHeap.h -> Implementing the Max Heap

test_avl_algo.cpp -> The file required by the checker to verify
tests specific to the AVL algorithm

test_avl_algo.cpp -> The file required by the checker to verify
tests specific to the Heap algorithm

checker_avl_algo.cpp checker_heap_algo.cpp -> two checkers made for
to test the correctness of the tests, their output and to determine
duration of execution of a test

Makefile -> The makefile that contains the build and run rules

Readme -> The file that contains details about the archive and implementations

checker.py -> the checker that verifies the correctness of the tests

generator.py -> python script to generate tests

in -> the folder contains input tests (input tests)

out -> the folder contains out tests (output tests)

test_out -> the folder contains the tests generated by checker_avl and checker_heap

------------------------------------------------------------------------------

## Implementation :

The implementation of the two algorithms was done using the C ++ language,
and for a good modularization of the code I chose to use header files.

# AVL :

## Functions :

- add -> add a new node in Avl
- remove_max -> the maximum item is obtained, and then it is deleted
- max_element -> returns the element with the maximum value
- preorder -> function that displays avl elements in preorder (debug)
- height -> within this function the height of a node is calculated
- preorder_util -> auxiliary function that displays the value of the current item
and then scroll left and right under the tree
- create_node -> function creates a new node with a desired value
- rotate_right -> in this function a right rotation is performed
of a node and the height is updated
- rotate_left -> similar to the rotate_right function except that a rotation is applied
to the left of the node
- get_balance -> within this function the equilibrium factor is calculated
of a node by the difference in heights between the left and right subtree
- fix_avl -> within this function the equilibrium factor is calculated and
then balance the shaft using right and left rotations
- min_node -> determines the node with the minimum value in avl
- max_node -> determines the node with the maximum value in avl
- add_util -> add node as inserted in a binary search tree,
and then the height is updated and the avl is balanced
- remove_util -> in this function we look for the node with the value that
we want to delete it, then delete the node. If the node does not have two successors, this one
it will be replaced by one of its non-zero successors. Otherwise the node will be replaced
with the smallest node in the right subtree.

# HEAP :

I chose to implement the max heap using an STL vector, removing the information
related to pointers, print using a formula to calculate the parent and
copies of a node based on the index in the vector.

## Functions :

- parent -> returns the parent of the node with the index i
- left_child_node -> returns the left child of the node with index i
- right_child_node -> returns the right child of node with index i
- size -> within this function we return the current size of the heap
- is_empty -> check if the heap contains items, or if it is empty
- heapify_down -> the recursive function that ensures the rearrangement of the elements
to maintain the max heap rule. Heapify down is used when
we remove the upper element from the heap.
- heapify_up -> the recursive function that ensures the rearrangement of the elements
to maintain the max heap rule. We use the function when inserting a new one
item in a heap. We add it to the bottom of the heap tree and pass
up in the tree as we compare with the current parent element and them
we exchange if necessary.
- add -> in this function we add a new element at the end of the vector
then we determine the last position and apply the heapify_up function to
rearrange the elements.
- max_element-> within this function we return the element from the first one
position in vector (highest value element)
- remove_max -> in this function we access the last element in the vector,
we add it to the first position, delete the last element and call the function
heapify_down on the first node to rearrange the items in the desired order

-------------------------------------------------- ----------------------------

## TEST_AVL_ALGO.cpp TEST_HEAP_ALGO.cpp

These two files contain the code needed by the checker to test the algorithms.
In them I created the two files (the input and the output).
Then I read the data from the input file, I ran the algorithm based on it
inputs and I redirected the results to output files.

-------------------------------------------------------------------------------

## CHECKER_AVL_ALGO.cpp CHECKER_HEAP_ALGO.cpp

These two files contain the source code of two checkers made using c ++.
We created these two files to test the correctness of the algorithms
implemented to determine the execution time of each specific test
an algorithm, respectively for debugging.

In the programs, for a given number of tests, I read the input data
from the in folder, run the algorithm and display the results in the folder
TEST_OUT / algorithm. Then I check if the output files obtained are identical
with those in the OUT folder. If so, I posted a message
"Test passed", and in case of contract I display "Test failed". For each test I have
determined the execution time from the point where the algorithm starts running
and to the end. I displayed as output time in microseconds.

-------------------------------------------------------------------------------

## Folder Structure IN / OUT / TEST_OUT

folder in:

-> contains 23 input tests that will be applied to each algorithm
-> each test is called "testX.in", where X represents the test number

TEST STRUCTURE
-> in each test there are a series of commands
-> if the command name is PUSH a value will be read and it will be realized
adding that value to the queue (push operation)
-> if the command name is pop, the priority item will be deleted
tail maximum (pop operation)
-> if the command name is top, the priority item will be returned
maximum in the queue (top operation)


tests [1-8] -> check a small number of operations
            -> tests the general correctness of the implementation
            -> elements have values ​​between [0 - 1000]
            -> are inserted in the queue between [0 - 100] elements

test [9] -> contains 1000 push operations
            -> items are added in ascending order
            -> items have values ​​between [0 -1000]

test [10] -> contains 1000 push operations
            -> items are added in descending order
            -> items have values ​​between [0 - 10000]

tests [11-15] -> contain between 0-10000 operations
              -> element values ​​are between [0-10000]
            
             
tests [16-18] -> contain between [10000-99999] operations
              -> element values ​​are between [0-90000]
            

tests [19-20] -> contain over 100,000 operations
              -> element values ​​are between [0-100000]

tests [21-22] -> contain over 1,000,000 operations
             -> element values ​​are between [0-1000000]
             -> tests in a complex way the implemented algorithms

test [23] -> contains over 10000000 operations
           -> element values ​​are between [0-1000000]

For tests [11-23] a random number of operations is first generated
push and then a random number of different operations is generated.
     

folder out:
-> contains three folders: best, p1 and p2 because it exists in the tests
items with the same priority (duplicates), and the output generated is different
for the two algorithms
-> each subfolder contains 23 output tests which represent the tests
correct what should be obtained
-> each test is called "testX.out", where X is the test number

test_out folder:
-> contains two folders: p1 and p2
-> each subfolder contains 23 output tests, generated after running
checker_avl_algo.cpp and checker_heap_algo.cpp files
-> each test is called "testX.out", where X is the test number

-------------------------------------------------- ----------------------------

## CHECKER.py

Checker designed to test the correctness of algorithms.

-------------------------------------------------------------------------------

## GENERATOR.py

This file contains the source code of a python script to
generate a series of randomized tests based on criteria using the randomized module.
To perform a test, a series of data are entered from the keyboard:

- the number of the test we want to create
- the number of items in the number list
- maximum range of elements
- yes / no if we want a list of sorted numbers
    - sorted list - ascending
                    - Descending
- upper limit for the number of push operations
- upper limit for the number of random operations

In the generator, we created a list of the three commands. Then I
created based on the data entered from the keyboard a list of numbers, which can
be sorted or not. I created a file for the desired test, and randomly generated it
a number of push operations that I displayed in the file. Then I generated
random a number of operations out of the three possible. The values ​​that are
added to the queue are randomly generated from the list of numbers originally created.

-------------------------------------------------------------------------------

## Makefile:
```
- build:
        compiles all executables

- run-best
        testing the best algorithm

- run-p1
        heap algorithm testing

- run-p2
        testing the avl algorithm

- Maxheap.o
        compiles the heap executable
        
- test_heap.o
        compiles the executable for testing the heap algorithm

- AVL.o
        compiles the executable for avl

- test_avl.o
        compiles the executable for testing the avl algorithm

- checker-avl-cpp:
        compiles and runs the secondary checker for avl

- checker-heap-cpp:
        compiles and runs the secondary heap checker

- clean
```
-------------------------------------------------------------------------------

## Useful Commands
```
Generator run:

python3 generator.py

Run checker Heap algorithm:

python3 checker.py --algo p1 --task 6 --unique-tests

Run AVL checker algorithm:

python3 checker.py --algo p2 --task 6 --unique-tests

Run checker best algorithm:

python3 checker.py --algo best --task 6 --unique-tests
```

## References:

Inspiration and Code Sequences taken from:

https://www.geeksforgeeks.org/avl-tree-set-1-insertion/

https://www.geeksforgeeks.org/avl-tree-set-2-deletion/

https://www.softwaretestinghelp.com/avl-trees-and-heap-data-structure-in-cpp/

https://ocw.cs.pub.ro/courses/sd-ca/laboratoare/lab-11

https://ocw.cs.pub.ro/courses/sd-ca/laboratoare/lab-09 

------------------------------------------------------------------------------
